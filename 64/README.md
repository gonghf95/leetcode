1. 描述

   给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

   说明：每次只能向下或者向右移动一步。

2. 输入输出

	```
	输入:
	[
    	[1,3,1],
    	[1,5,1],
    	[4,2,1]
	]
	输出: 7
	解释: 因为路径 1→3→1→1→1 的总和最小。
	```

3. 算法

   1. 初始化队列Q，其存储为当前要处理的节点的坐标对。
   2. 将左上角节点坐标加入队列
   3. 若队列不为空，依次将队列Q中节点弹出
   4. 对弹出节点， 如果它为右下角节点坐标，则返回节点值。否则把它的值与它左节点与上节点中的较小值相加，并把还未访问过的子节点加入到队列中
   5. 重复3-4